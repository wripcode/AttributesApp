"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Webflow = exports.SCOPES_ARRAY = exports.USER_AGENT = exports.DEFAULT_HOST = void 0;
const axios_1 = __importDefault(require("axios"));
const core_1 = require("../core");
const api_1 = require("../api");
exports.DEFAULT_HOST = "webflow.com";
exports.USER_AGENT = "Webflow Javascript SDK / 1.0";
exports.SCOPES_ARRAY = [
    "assets:read",
    "assets:write",
    "authorized_user:read",
    "cms:read",
    "cms:write",
    "custom_code:read",
    "custom_code:write",
    "forms:read",
    "forms:write",
    "pages:read",
    "pages:write",
    "sites:read",
    "sites:write",
    "users:read",
    "users:write",
    "ecommerce:read",
    "ecommerce:write",
];
/**************************************************************
 * Class
 **************************************************************/
class Webflow {
    constructor(options = {}) {
        this.options = options;
        this.client = axios_1.default.create(this.config);
        this.client.interceptors.response.use(core_1.ErrorInterceptor);
        if (this.options.beta) {
            this.removeNonBetaMethods();
        }
    }
    removeNonBetaMethods() {
        const methodsToRemove = [
            "info",
            "authenticatedUser",
            "sites",
            "site",
            "publishSite",
            "domains",
            "collections",
            "collection",
            "items",
            "item",
            "createItem",
            "updateItem",
            "patchItem",
            "removeItem",
            "deleteItems",
            "publishItems",
        ];
        methodsToRemove.forEach((method) => {
            Object.defineProperty(this, method, {
                value: function () {
                    throw new Error(`The method '${method}()' is not available in beta mode. Please disable the beta option to use this method.`);
                },
                enumerable: false,
                configurable: true,
            });
        });
    }
    // Set the Authentication token
    set token(value) {
        this.options.token = value;
    }
    // clear the Authorization header
    clearToken() {
        delete this.options.token;
    }
    // The Axios configuration
    get config() {
        const { host = exports.DEFAULT_HOST, token, version, headers, beta = false } = this.options;
        const effectiveHost = beta ? "webflow.com/beta" : host;
        const config = {
            baseURL: `https://api.${effectiveHost}/`,
            headers: {
                "Content-Type": "application/json",
                "User-Agent": exports.USER_AGENT,
                ...headers,
            },
        };
        // Add the version to the headers if passed in
        if (version)
            config.headers["Accept-Version"] = version;
        // Add the Authorization header if a token is set
        if (token)
            config.headers.Authorization = `Bearer ${token}`;
        config.paramsSerializer = {
            serialize: (params) => {
                if (typeof params !== "object" || params === null) {
                    return "";
                }
                const parts = [];
                for (const key in params) {
                    const value = params[key];
                    if (value === undefined)
                        continue;
                    const safeValue = typeof value === "string" || typeof value === "number" ? value : String(value);
                    if (key === "scope") {
                        parts.push(`${key}=${safeValue}`);
                    }
                    else {
                        parts.push(`${key}=${encodeURIComponent(safeValue)}`);
                    }
                }
                return parts.join("&");
            },
        };
        return config;
    }
    /**************************************************************
     * HTTP Methods
     **************************************************************/
    /**
     * Send a GET request to the Webflow API
     * @param path The path to the endpoint
     * @param params The query parameters (optional)
     * @returns The response from the Webflow API
     */
    get(path, params) {
        return this.client.get(path, { params });
    }
    /**
     * Send a DELETE request to the Webflow API
     * @param path The path to the endpoint
     * @param params The query parameters (optional)
     * @returns The response from the Webflow API
     */
    delete(path, params) {
        return this.client.delete(path, { params });
    }
    /**
     * Send a POST request to create a new Collection
     * @param path The path to the endpoint
     * @param data The data to send
     * @param params The query parameters (optional)
     * @returns The response from the Webflow API
     */
    post(path, data, params) {
        return this.client.post(path, data, { params });
    }
    /**
     * Send a PUT request to create a new Collection
     * @param path The path to the endpoint
     * @param data The data to send
     * @param params The query parameters (optional)
     * @returns The response from the Webflow API
     */
    put(path, data, params) {
        return this.client.put(path, data, { params });
    }
    /**
     * Send a PATCH request to create a new Collection
     * @param path The path to the endpoint
     * @param data The data to send
     * @param params The query parameters (optional)
     * @returns The response from the Webflow API
     */
    patch(path, data, params) {
        return this.client.patch(path, data, { params });
    }
    /**************************************************************
     * OAuth Endpoints
     **************************************************************/
    /**
     * Create an OAuth Authorization url
     * @param params The OAuth information
     * @param params.state The state parameter (optional)
     * @param params.scope The scope parameter (optional)
     * @param params.client_id The client_id parameter (optional)
     * @param params.redirect_uri The redirect_uri parameter (optional)
     * @param params.response_type The response_type parameter (default: "code")
     * @returns The url to redirect to
     */
    authorizeUrl(params) {
        return api_1.OAuth.authorizeUrl(params, this.client);
    }
    /**
     * Create an OAuth Access Token
     * @param params The OAuth information
     * @param params.code The code parameter
     * @param params.client_id The client_id parameter
     * @param params.client_secret The client_secret parameter
     * @param params.redirect_uri The redirect_uri parameter (optional)
     * @param params.grant_type The grant_type parameter (default: "authorization_code")
     * @returns The access token
     */
    async accessToken(params) {
        const res = await api_1.OAuth.accessToken(params, this.client);
        return res.data;
    }
    /**
     * Revoke an OAuth Access Token
     * @param params The access token information
     * @param params.access_token The access token
     * @param params.client_id The client_id parameter
     * @param params.client_secret The client_secret parameter
     * @returns The result of the revoked token
     */
    async revokeToken(params) {
        const res = await api_1.OAuth.revokeToken(params, this.client);
        return res.data;
    }
    /**************************************************************
     * Meta Endpoints
     **************************************************************/
    /**
     * Get the current authorization information
     * @returns The authorization information
     */
    async info() {
        const res = await api_1.Meta.info(this.client);
        return res.data;
    }
    /**
     * Get the current authenticated user
     * @returns The current authenticated user
     */
    async authenticatedUser() {
        const res = await api_1.Meta.user(this.client);
        return res.data;
    }
    /**************************************************************
     * Site Endpoints
     **************************************************************/
    /**
     * Get a list of Sites available
     * @returns A list of Sites
     */
    async sites() {
        const res = await api_1.Site.list(this.client);
        return res.data.map((data) => new api_1.Site(this.client, { ...res, data }));
    }
    /**
     * Get a single Site
     * @param params The Site information
     * @param params.siteId The Site ID
     * @returns The Site
     */
    async site({ siteId }) {
        const res = await api_1.Site.getOne({ siteId }, this.client);
        return new api_1.Site(this.client, res);
    }
    /**
     * Publish a Site
     * @param params The Site information
     * @param params.siteId The Site ID
     * @param params.domain The domains to publish
     * @returns The result of the publish
     */
    async publishSite({ siteId, domains }) {
        const res = await api_1.Site.publish({ siteId, domains }, this.client);
        return res.data;
    }
    /**
     * Get a list of Domains for a Site
     * @param params The Site information
     * @param params.siteId The Site ID
     * @returns A list of Domains
     */
    async domains({ siteId }) {
        const res = await api_1.Site.domains({ siteId }, this.client);
        return res.data;
    }
    /**************************************************************
     * Collection Endpoints
     **************************************************************/
    /**
     * Get a list of Collections
     * @param params The Site information
     * @param params.siteId The Site ID
     * @returns A list of Collections
     */
    async collections({ siteId }) {
        const res = await api_1.Collection.list({ siteId }, this.client);
        return res.data.map((data) => new api_1.Collection(this.client, { ...res, data }));
    }
    /**
     * Get a single Collection
     * @param params The Collection information
     * @param params.collectionId The Collection ID
     * @returns A single Collection
     */
    async collection({ collectionId }) {
        const res = await api_1.Collection.getOne({ collectionId }, this.client);
        return new api_1.Collection(this.client, res);
    }
    /**************************************************************
     * Item Endpoints
     **************************************************************/
    /**
     * Get a list of Collection Items
     * @param params The Collection information
     * @param params.collectionId The Collection ID
     * @param params.limit The number of items to return
     * @param params.offset The number of items to skip
     * @returns A list of Items
     */
    async items({ collectionId, limit, offset }) {
        const res = await api_1.Item.list({ collectionId, limit, offset }, this.client);
        return res.data.items.map((data) => new api_1.Item(this.client, { ...res, data }));
    }
    /**
     * Get a single Collection Item
     * @param params The Item information
     * @param params.collectionId The Collection ID
     * @param params.itemId The Item ID
     * @returns A single Collection Item
     */
    async item({ itemId, collectionId }) {
        const res = await api_1.Item.getOne({ itemId, collectionId }, this.client);
        const [item] = res.data.items.map((data) => new api_1.Item(this.client, { ...res, data }));
        return item;
    }
    /**
     * Create a new Collection Item
     * @param params The Item information
     * @param params.collectionId The Collection ID
     * @returns The created Collection Item
     */
    async createItem({ collectionId, fields }) {
        const res = await api_1.Item.create({ collectionId, fields }, this.client);
        return new api_1.Item(this.client, res);
    }
    /**
     * Update a Collection Item
     * @param params The Item information
     * @param params.collectionId The Collection ID
     * @param params.itemId The Item ID
     * @param query The query parameters (optional)
     * @returns The updated Collection Item
     */
    async updateItem({ collectionId, itemId, ...fields }) {
        const _params = { collectionId, itemId, fields };
        const res = await api_1.Item.update(_params, this.client);
        return new api_1.Item(this.client, res);
    }
    /**
     * Patch a Collection Item
     * @param params The Item information
     * @param params.collectionId The Collection ID
     * @param params.itemId The Item ID
     * @returns The patched Collection Item
     */
    async patchItem({ collectionId, itemId, ...fields }) {
        const _params = { collectionId, itemId, fields };
        const res = await api_1.Item.patch(_params, this.client);
        return new api_1.Item(this.client, res);
    }
    /**
     * Delete a Collection Item
     * @param params The Item information
     * @param params.collectionId The Collection ID
     * @param params.itemId The Item ID
     * @returns The deleted Collection Item result
     */
    async removeItem({ collectionId, itemId }) {
        const res = await api_1.Item.remove({ collectionId, itemId }, this.client);
        return res.data;
    }
    /**
     * Unpublish a Collection Item
     * @param params The Item information
     * @param params.collectionId The Collection ID
     * @param params.itemId The Item ID
     * @param params.live Update the live version
     * @returns The unpublished Collection Item result
     */
    async deleteItems({ collectionId, itemIds, live, }) {
        const res = await api_1.Item.unpublish({ collectionId, itemIds, live }, this.client);
        return res.data;
    }
    /**
     * Publish a Collection Item
     * @param params The Item information
     * @param params.collectionId The Collection ID
     * @param params.itemId The Item ID
     * @param params.live Update the live version
     * @returns The Published Collection Item result
     */
    async publishItems({ collectionId, itemIds, live, }) {
        const res = await api_1.Item.publish({ collectionId, itemIds, live }, this.client);
        return res.data;
    }
    /**************************************************************
     * Membership Endpoints
     **************************************************************/
    /**
     * Get a list of User accounts
     * @param params The Site information
     * @param params.siteId The Site ID
     * @param pageParams The pagination information (optional)
     * @returns A list of User accounts
     */
    async users({ siteId }, pageParams) {
        const res = await api_1.User.list({ siteId, ...pageParams }, this.client);
        return res.data.users.map((data) => new api_1.User(this.client, { ...res, data }));
    }
    /**
     * Get a single User account
     * @param param The Site and User information
     * @param param.siteId The Site ID
     * @param param.userId The User ID
     * @returns The User information
     */
    async user({ siteId, userId }) {
        const res = await api_1.User.getOne({ siteId, userId }, this.client);
        return new api_1.User(this.client, res, res.data, { siteId });
    }
    /**
     * Update a User account
     * @param params The Site and User information
     * @param params.siteId The Site ID
     * @param params.userId The User ID
     * @returns The updated User
     */
    async updateUser({ siteId, userId, ...data }) {
        const _params = { siteId, userId, data };
        const res = await api_1.User.update(_params, this.client);
        return new api_1.User(this.client, res, res.data, { siteId });
    }
    /**
     * Invite a User to a Site
     * @param params The Site and User information
     * @param params.siteId The Site ID
     * @param params.email The User's email address
     * @returns The created User account
     */
    async inviteUser({ siteId, email }) {
        const res = await api_1.User.invite({ siteId, email }, this.client);
        return new api_1.User(this.client, res, res.data, { siteId });
    }
    /**
     * Remove a user from a Site
     * @param params The Site and User information
     * @param params.siteId The Site ID
     * @param params.userId The User ID
     * @returns The result from the remove request
     */
    async removeUser({ siteId, userId }) {
        const res = await api_1.User.remove({ siteId, userId }, this.client);
        return res.data;
    }
    /**
     * Get a list of User Access Groups
     * @param params The params for the request
     * @param params.siteId The site ID
     * @param params.limit The number of items to return (optional)
     * @param params.offset The number of items to skip (optional)
     * @param params.sort The sort order of the groups (optional)
     * @returns A list of Access Groups
     */
    async accessGroups({ siteId, limit, offset, sort, }) {
        const params = { siteId, limit, offset, sort };
        const res = await api_1.User.accessGroups(params, this.client);
        return res.data;
    }
    /**************************************************************
     * Webhook Endpoints
     **************************************************************/
    /**
     * Get a list of webhooks for a Site
     * @param params The site information to get the Webhooks from
     * @param params.siteId The Site ID
     * @returns A list of Webhooks
     */
    async webhooks({ siteId }) {
        const res = await api_1.Webhook.list({ siteId }, this.client);
        return res.data.map((data) => new api_1.Webhook(this.client, { ...res, data }));
    }
    /**
     * Get a single Webhook
     * @param params The Webhook and Site information
     * @param params.siteId The Site Id
     * @param params.webhookId The Webhook Id
     * @returns The Webhook
     */
    async webhook({ siteId, webhookId }) {
        const res = await api_1.Webhook.getOne({ siteId, webhookId }, this.client);
        return new api_1.Webhook(this.client, res);
    }
    /**
     * Remove a Webhook
     * @param params The Webhook and Site information
     * @param params.siteId The Site Id
     * @param params.webhookId The Webhook Id
     * @returns the result from the remove request
     */
    async removeWebhook({ siteId, webhookId }) {
        const res = await api_1.Webhook.remove({ siteId, webhookId }, this.client);
        return res.data;
    }
    /**
     * Create a Webhook
     * @param params The params to create a webhooks
     * @param params.siteId The Site Id
     * @param params.url The Url the Webhook should call on events
     * @param params.triggerType The type of event that should trigger the Webhook
     * @param params.filter The filter to apply to the Webhook (form_submission only)
     * @returns The created webhook
     */
    async createWebhook({ url, siteId, triggerType, filter, }) {
        const _params = { url, siteId, triggerType, filter };
        const res = await api_1.Webhook.create(_params, this.client);
        return new api_1.Webhook(this.client, res);
    }
}
exports.Webflow = Webflow;
